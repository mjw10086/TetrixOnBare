# 一个在裸机上运行的俄罗斯方块

这个项目是很大程度上是自制操作系统的皮毛，主要目的是在裸机上运行俄罗斯方块，涉及到操作系统与硬件的基本交互，但是不包含操作系统的核心技术比如进程和内存管理。

本项目按任务分为以下阶段：

- 引导扇区的创建，打印hello world
- 由实模式进入保护模式
- 在裸机运行C语言程序
- 在VGA模式下显示内容
- 实现中断的支持
- Tetris

# 引导扇区的创建，打印hello world

计算机启动后，主板上内置的BIOS程序首先运行，BIOS进行一系列自检后从外部存储设置中检查可引导扇区，如果存在可引导扇区那么将引导扇区加载到内存地址`0x7c00`处，并跳转到该内存地址开始执行。

本节内容需要的知识：
- Intel或者AT&T汇编语言
- 汇编语言编译器和链接器工具的使用
- 理解并使用BIOS中断
- Bochs基本使用
- Makefile的基本使用

## 可引导扇区的结构

可引导扇区主要特征如下：
- 外部存储设备的第一个扇区，也就是0号扇区
- 一个扇区大小为512字节，并且以`0xaa55`为结尾（以0号字节为起始，即510字节为0x55，511字节为0xaa）

## 使用BIOS中断清屏以及打印hello world

使用`int 0x10`来调用BIOS中断打印字符，其参数和功能通过寄存器来传递，详情参见代码文件`boot.asm`。

## Makefile自动化构建以及Bochs调试

Makefile提供构建脚本，注意`boot.asm`汇编的链接参数，`-Ttext=0x7c00`表示程序装在到内存的位置，`--oformat binary`表示生成数据的原始二进制Blob，而不是elf格式。

在Bochs中则指定了BIOS和VGABIOS，并且设置机器的物理内存大小和机器的外接存储设备。

# 由实模式进入保护模式

在上一节我们打印Hello World是在实模式下实现的，由于实模式下可访问内存受限，因此我们要切换到保护模式。有关于实模式、保护模式以及64位时代的长模式的介绍请自行搜索理解。

进入保护模式需要执行以下几个操作：

- 加载GDT
- 打开A20地址线
- 修改CR0寄存器

接下来逐一介绍。

## 加载GDT

GDT（全局描述符表）是指导CPU如何进行分段数据结构，有关什么是分段请参考操作系统内存管理章节。GDT位于内存中，有着固定的数据结构格式，CPU通过GDTR寄存器来获取GDT表的内存位置。

有关GDT的详细格式可以参考《Linux内核完全解析 5.0》一书中的介绍。

在这部分我们要做的是
1. 设置GDT表
2. 设置GDTR寄存器

具体内容`boot.asm`参考代码中`gdt`关键词的部分。

## 打开A20地址线

关于A20地址线的历史情况，在《Linux内核完全解析 5.0》的 6.3.34 介绍的非常详细。

A20地址线的开启有两种代码，一种是传统的方法，一种则是FAST A20。关于两种方法的操作请参考[https://wiki.osdev.org/A20#Enabling](https://wiki.osdev.org/A20#Enabling)。这里采取的是FAST A20的做法。

## 修改CR0寄存器

通过修改CR0开启保护模式，主要是针对PE位做修改，当为1时即开启保护模式。在设置完毕CR0后需要使用JMP指令刷新指令队列。

## 测试功能

在开启保护模式之后，程序可以访问到多于1MB的空间。通过对VRAM显存的设置来在屏幕上打印字符，从而测试保护模式是否成功运行。或者，我们可以通过Bochs的调试命令，查看CPU当前的模式。

## 参考资料

- 《Linux内核完全解析 5.0》
- [https://wiki.osdev.org/A20](https://wiki.osdev.org/A20)
- [https://en.wikipedia.org/wiki/Global_Descriptor_Table#GDT_example](https://en.wikipedia.org/wiki/Global_Descriptor_Table#GDT_example)

# 在裸机运行C语言程序

在裸机上运行比汇编更高级的语言是开发的需要，固然汇编能够完成，但是没有必要那么难为自己。我们在裸机上运行C语言需要解决的问题有以下几个。

- C语言要编译
- 要把程序从硬盘读到内存中
- 要把执行权交给C语言程序

## C语言程序编写

在日常编写用户程序时，会引用很多的“外部”函数，但是在裸机上，由于这些函数没有被实现，所以不能使用。一定要使用这些函数的情况下，这些函数需要手动实现，可能会存在这C语言如何调用汇编代码的问题，这里需要学习。

具体编译命令可以查看项目中的Makefile代码。

## 把程序从硬盘读到内存中

关于如何把程序装在到“硬盘”上，可以依赖`dd`命令来实现。在加载C语言之前，只能依赖汇编编写程序读取硬盘内容。这里的代码摘自
[https://www.cnblogs.com/flashsun/p/12235761.html](https://www.cnblogs.com/flashsun/p/12235761.html)。

## 把执行权交给C语言程序

这部分就要利用长跳转函数来实现，在上面保护模式的内容中有提及，这里要注意，我们在跳转C语言程序之前，一定要把对应的段寄存器设置好，比如说ES、DS、SS。还有就是确定栈的起始位置，因为我们当前执行的代码位置在0x7c00靠后的部分（根据代码内容有所不同），由于在C语言模型中，栈是从内存高地址向低地址生长的，在没有设置合适的栈位置时很容易会把前面引导扇区在内存中的内容覆盖掉，尤其严重的是覆盖掉GDT。

关于要跳转的位置，可以采用ida64等软件查看入口函数的偏移位置来计算得到，这里的入口可以是`__start`函数，或者通过编译选项设置的入口。

## 总结

本章的代码量很少，只是基础的引入C语言环境，后续会以C语言为主，汇编为辅来实现具体的俄罗斯方块功能。关于后续的业务代码，不做过多的讲解，主要讲述业务代码中涉及到与机器交互的部分，以以下几个内容为主

- 图像显示
- 控制游戏速度的sleep函数以及键盘按键的检测
